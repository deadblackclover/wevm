import com.github.sbt.jni.build.Cargo
import com.typesafe.sbt.git.JGit
import scala.sys.process._

import scala.jdk.CollectionConverters._

enablePlugins(GitVersioning)

name := "wevm"

normalizedName := {name.value}

organization := "com.wavesenterprise"


libraryDependencies += "org.scalatest" %% "scalatest" % "3.1.0" % "test"
libraryDependencies += "com.wavesenterprise" % "we-core" % "1.14.0" % "test"

assembly / artifact := {
  val art = (assembly / artifact).value
  art.withClassifier(Some("assembly"))
}


addArtifact(assembly / artifact, assembly)

publish := (publish dependsOn (Compile / assembly)).value

publishLocal := (publishLocal dependsOn (Compile / assembly)).value

version in ThisBuild := {
  val suffix         = git.makeUncommittedSignifierSuffix(git.gitUncommittedChanges.value, Some("DIRTY"))
  val releaseVersion = git.releaseVersion(git.gitCurrentTags.value, git.gitTagToVersionNumber.value, suffix)
  lazy val describedExtended = git.gitDescribedVersion.value.map { described =>
    val commitHashLength                          = 7
    val (tagVersionWithoutCommitHash, commitHash) = described.splitAt(described.length - commitHashLength)
    val tagVersionWithCommitsAhead                = tagVersionWithoutCommitHash.dropRight(2)
    s"$tagVersionWithCommitsAhead-$commitHash" + suffix
  }
  releaseVersion.orElse(describedExtended).getOrElse(git.formattedDateVersion.value)
}


ThisBuild / assemblyMergeStrategy := {
  case PathList("META-INF", xs @ _*) => MergeStrategy.discard
  case x => MergeStrategy.first
}

lazy val branchName = Def.setting[String](sys.env.getOrElse("CI_COMMIT_REF_NAME", git.gitCurrentBranch.value))


/**
  * The version is generated by the first possible method in the following order:
  *   Release version – {Tag}[-DIRTY]. When the tag corresponding to the version pattern is set on the last commit;
  *   Snapshot version – {Tag}-{Commits-ahead}-{Branch-name}-{Commit-hash}[-DIRTY]-SNAPSHOT. When the `git describe --tags` is worked;
  *   Fallback version – {Current-date}-SNAPSHOT.
  */
ThisBuild / version := {
  if (git.gitUncommittedChanges.value) {
    val changes = JGit(baseDirectory.value).porcelain
      .status()
      .call()
      .getUncommittedChanges
      .asScala
      .mkString("\n")

    println(s"Uncommitted changes detected:\n$changes")
  }

  val uncommittedChangesSuffix = git.makeUncommittedSignifierSuffix(git.gitUncommittedChanges.value, Some("DIRTY"))
  val snapshotSuffix           = "SNAPSHOT"

  val releaseVersion = git.releaseVersion(git.gitCurrentTags.value, git.gitTagToVersionNumber.value, uncommittedChangesSuffix)

  lazy val snapshotVersion = git.gitDescribedVersion.value.map { described =>
    val commitHashLength                          = 7
    val (tagVersionWithoutCommitHash, commitHash) = described.splitAt(described.length - commitHashLength)
    val tagVersionWithCommitsAhead                = tagVersionWithoutCommitHash.dropRight(2)
    val branchSuffix                              = branchName.value
    s"$tagVersionWithCommitsAhead-$branchSuffix-$commitHash$uncommittedChangesSuffix-$snapshotSuffix"
  }

  lazy val fallbackVersion = s"${git.formattedDateVersion.value}-$snapshotSuffix"

  (releaseVersion orElse snapshotVersion) getOrElse fallbackVersion
}

ThisBuild / versionScheme := Some("semver-spec")

lazy val isSnapshotVersion: Def.Initialize[Boolean] = version(_ endsWith "-SNAPSHOT")

lazy val wePublishingRepo: Def.Initialize[Some[Resolver]] = isSnapshotVersion {
  case true =>
    Some("Sonatype Nexus Snapshots Repository Manager" at "https://artifacts.wavesenterprise.com/repository/we-snapshots")
  case _ =>
    Some("Sonatype Nexus Repository Manager" at "https://artifacts.wavesenterprise.com/repository/we-releases")
}

lazy val publicationSettings: Def.Setting[Task[Option[Resolver]]] =
  publishTo := wePublishingRepo.value


ThisBuild / credentials += {
  val envUsernameOpt = sys.env.get("nexusUser")
  val envPasswordOpt = sys.env.get("nexusPassword")

  (envUsernameOpt, envPasswordOpt) match {
    case (Some(username), Some(password)) =>
      println(
        "Using credentials from environment for artifacts.wavesenterprise.com"
      )
      Credentials(
        "Sonatype Nexus Repository Manager",
        "artifacts.wavesenterprise.com",
        username,
        password
      )

    case _ =>
      val localCredentialsFile = Path.userHome / ".sbt" / ".credentials"
      println(
        s"Going to use ${localCredentialsFile.getAbsolutePath} as credentials for artifacts.wavesenterprise.com"
      )
      Credentials(localCredentialsFile)
  }
}

lazy val wevm = (project in file("."))
  .settings(
    organization := (ThisBuild / organization).value,
    sbtJniCoreScope := Compile,
    classLoaderLayeringStrategy := ClassLoaderLayeringStrategy.Flat,
    assembly / assemblyJarName := s"wevm_${scalaVersion.value.reverse.dropWhile(_ != '.').drop(1).reverse.take(4)}-${version.value}.jar",
    publishArtifact in (Compile, packageSrc) := true,
    publishArtifact in (Compile, packageBin) := true,
    publishArtifact in (Compile, packageDoc) := true,
    addArtifact(artifact in (Compile, assembly), assembly),
  )
  .settings(publicationSettings)
  .aggregate(wevmNative)
  .dependsOn(wevmNative % Runtime)

wevmNative / organization := "com.wavesenterprise"
wevmNative / name := "wevm-native"

// see this tutorial https://engineering.avast.io/scala-and-rust-interoperability-via-jni/
lazy val wevmNative = (project in file("native"))
  .settings(crossPaths := false)
  .settings(
    nativeCompile / sourceDirectory := baseDirectory.value,
    nativeBuildTool := Cargo.make(Seq("--release", "--features jvm"))
  )
  .settings(publicationSettings)
  .settings(
    publish / skip := false
  )
  .enablePlugins(JniNative, JniPackage)

lazy val buildWAT = taskKey[Unit]("build WAT contract")
buildWAT := {
  val wat2wasm = baseDirectory.value / "wat2wasm"

  val input = baseDirectory.value / "wat"
  val output = baseDirectory.value / "src" / "test" / "resources"

  val success: Int = ( s"cargo run --manifest-path ${wat2wasm}/Cargo.toml -- --input ${input} --output ${output}" #&& "echo WAT build successfully" ! )
}
